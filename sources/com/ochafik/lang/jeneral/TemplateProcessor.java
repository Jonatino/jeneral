package com.ochafik.lang.jeneral;

import static com.ochafik.lang.SyntaxUtils.*;
import static com.ochafik.util.string.StringUtils.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.ochafik.lang.annotation.AbstractProcessor;
import com.ochafik.lang.jeneral.annotations.Instantiate;
import com.ochafik.lang.jeneral.annotations.Template;
import com.ochafik.lang.jeneral.annotations.TemplatesHelper;
import com.ochafik.util.listenable.AdaptedCollection;
import com.ochafik.util.listenable.Adapter;
import com.sun.mirror.apt.AnnotationProcessorEnvironment;
import com.sun.mirror.apt.Filer;
import com.sun.mirror.declaration.AnnotationTypeDeclaration;
import com.sun.mirror.declaration.ClassDeclaration;
import com.sun.mirror.declaration.ConstructorDeclaration;
import com.sun.mirror.declaration.Declaration;
import com.sun.mirror.declaration.Modifier;
import com.sun.mirror.declaration.TypeDeclaration;
import com.sun.mirror.declaration.TypeParameterDeclaration;
import com.sun.mirror.type.InterfaceType;
import com.sun.mirror.type.ReferenceType;

/*
cd /Users/ochafik/Prog/Java && rm templates_logs.txt >/dev/null ; apt -factory com.ochafik.lang.templates.TemplateProcessorFactory -d classes/ -s sources/.apt_generated/ -cp sources:classes sources/com/ochafik/lang/templates/*.java && open templates_logs.txt
 */
public class TemplateProcessor extends AbstractProcessor {
	private static final String 
		GENERATED_INTERFACE_SUFFIX = "_Template",
		GENERATED_REIFICATOR_NAME = "Factory",
		NEW_ARRAY_METHOD_FORMAT = "new_%s_array",
		NEW_OBJECT_METHOD_FORMAT = "new_%s";
		
	//private Class<?> dep = ReificationUtils.class;

	public TemplateProcessor(AnnotationProcessorEnvironment env){
		super(env);
		log("Template Processor created");
	}

	static String computeInstanceName(String baseName, TypeDeclaration... types) {
		StringBuilder b = new StringBuilder(baseName);
		for (TypeDeclaration type : types) {
			b.append("__");
			b.append(type.getSimpleName());
		}
		return b.toString();
	}
	public void process() {
		AnnotationTypeDeclaration templateAnno = getAnnotationType(Template.class);
		for (Declaration dec : environment.getDeclarationsAnnotatedWith(templateAnno)) {
			if (!(dec instanceof ClassDeclaration)) {
				printError(dec, "Only classes may be annotated with " + Template.class.getName());
				continue;
			}
			ClassDeclaration decl = (ClassDeclaration)dec;
			try {
				processTemplateClass(decl);
			} catch (Throwable t) {
				logError(t);
			}
		}
		
		AnnotationTypeDeclaration instantiationAnno = getAnnotationType(Instantiate.class);
		for (Declaration dec : environment.getDeclarationsAnnotatedWith(instantiationAnno)) {
			try {
				processInstantiation(dec);
			} catch (Throwable t) {
				logError(t);
			}
		}
	}

	private void processTemplateClass(ClassDeclaration decl) throws IOException {
		Template anno = decl.getAnnotation(Template.class);
		if (anno.reifiable()) {
			
			if (!decl.getModifiers().contains(Modifier.ABSTRACT)) {
				printError(decl, "Template "+decl.getQualifiedName()+" must be declared as abstract.");
				return;
			}
			
			Filer filer = environment.getFiler();
			String interfaceQualifiedName = decl.getQualifiedName() + GENERATED_INTERFACE_SUFFIX;
			String interfaceName = decl.getSimpleName() + GENERATED_INTERFACE_SUFFIX;
			
			LinesFormatter f = new LinesFormatter(filer.createSourceFile(interfaceQualifiedName), "");
			//String interface
			
			String packageName = decl.getPackage().getQualifiedName();
			String genericParamsDefinition = implode(decl.getFormalTypeParameters());
			if (genericParamsDefinition.length() > 0)
				genericParamsDefinition = "<" + genericParamsDefinition + ">";
			
			f.format(array(
					"//",
					"// This file was autogenerated by {5} from {0}",
					"//",
					packageName.length() == 0 ? null : "package {1};",
					"",
					"@{2}",
					"interface {3}{4} '{'"
				), 
				decl.getQualifiedName(), 
				packageName,
				TemplatesHelper.class.getName(),
				interfaceName, 
				genericParamsDefinition, 
				getClass().getName()
			);
			
			List<String> genericParamNames = new ArrayList<String>(getFormalTypeNames(decl));
			for (String type : genericParamNames) {
				f.format(array(
						"/**",
						"	Returns the class of the generic parameter {1}",
						"*/",
						"{0}<{1}> {1}();", 
						"",
						"/**",
						"	Creates a new array of elements of class {1}.<br/>",
						"	Equivalent to a call to java.lang.reflect.Array.newInstance({2}.{1}(), length)",
						"*/",
						"{1}[] " + String.format(NEW_ARRAY_METHOD_FORMAT, type) + "(int length);",
//						"",
//						"/**",
//						"	Creates a new instance of class {1}, using its default constructor.<br/>",
//						"	Equivalent to a call to {2}.newInstance()",
//						"*/",
//						"{1} " + String.format(NEW_OBJECT_METHOD_FORMAT, type) + "()" +(anno.paramFactoryThrowsExceptions() ? " throws {3}, {4};" : ";"),
						""
					),
					Class.class.getName(),
					type, 
					interfaceName,
					InstantiationException.class.getName(),
					IllegalAccessException.class.getName()
				);
				
			}
			/*String genericParamsDefinition = implode(new AdaptedCollection<TypeParameterDeclaration, String>(decl.getFormalTypeParameters(), new Adapter<TypeParameterDeclaration, String>() { public String adapt(TypeParameterDeclaration value) {
				return value.getSimpleName() + (value.getBounds().isEmpty() ? "" : " extends " + implode(value.getBounds()));//.toString();
			}}));
			
			if (genericParamsDefinition.length() > 0)
				genericParamsDefinition = "<" + genericParamsDefinition + ">";
			*/
			
			String genericParamsUsage = implode(genericParamNames);
			if (genericParamsUsage.length() > 0)
				genericParamsUsage = "<" + genericParamsUsage + ">";
			
			f.println("@SuppressWarnings(\"unchecked\")");
			f.println("public final class " + GENERATED_REIFICATOR_NAME + " {");
			
			for (ConstructorDeclaration constructor : decl.getConstructors()) {
				if (!constructor.getModifiers().contains(Modifier.PUBLIC))
					continue;
				
				Collection<ReferenceType> throwns = constructor.getThrownTypes();
				String throwsClause = throwns.isEmpty() ? "" : "throws " + implode(throwns, ", ");
				
				List<String> factoryArgsDeclaration = new ArrayList<String>();
				collectGenericParamsArgumentsDeclaration(genericParamNames, true, false, factoryArgsDeclaration);
				collectArgumentsDeclaration(constructor.getParameters(), false, false, factoryArgsDeclaration);
				
				f.printfn(
					"public static final %s %s%s newInstance(%s) %s {",
					genericParamsDefinition,
					decl.getQualifiedName(), 
					genericParamsUsage,
					implode(factoryArgsDeclaration), 
					throwsClause); 
						 
				List<String> paramClassesArgNames = collectGenericParamsArgumentsDeclaration(genericParamNames, false, true, null);
				List<String> constructorArgNames = collectArgumentsDeclaration(constructor.getParameters(), false, true, null);
				
				List<String> argCall = new ArrayList<String>();
				collectGenericParamsArgumentsDeclaration(genericParamNames, false, true, argCall);
				collectArgumentsDeclaration(constructor.getParameters(), false, true, argCall);
				
				
				f.printfn(
					"return new %s(%s) {",
					 decl.getQualifiedName(), 
					 implode(constructorArgNames, ", "));
				
				for (int i = 0, len = genericParamNames.size(); i < len; i++) {
					String type = genericParamNames.get(i);
					String argName = paramClassesArgNames.get(i);
					
					f.format(array(
						"public final {0}<{1}> {1}() '{'",
							"return {2};", 
						"'}'"), 
						Class.class.getName(), 
						type,
						argName);
					
					f.format(array(
							"public final {0}[] " + String.format(NEW_ARRAY_METHOD_FORMAT, type) + "(int length) '{'",
								"return ({0}[]){1}.newInstance({2}, length);", 
							"'}'"), 
							type, 
							java.lang.reflect.Array.class.getName(), 
							argName);
				/*		
					f.format(array(
							"public final {0} " + String.format(NEW_OBJECT_METHOD_FORMAT, type) + "()"+(anno.paramFactoryThrowsExceptions() ? " throws {1}, {2} '{'" : " '{'"),
								anno.paramFactoryThrowsExceptions() ?
									null : 
									"try '{'",
								"return {3}.newInstance();",
								anno.paramFactoryThrowsExceptions() ? 
									null :
									"'}' catch ({1} ex) '{'\n" +
										"throw new RuntimeException(ex);\n" +
									"'}' catch ({2} ex) '{'\n" +
										"throw new RuntimeException(ex);\n" +
									"'}'",
							"'}'"), 
							type, 
							InstantiationException.class.getName(),
							IllegalAccessException.class.getName(),
							argName);
				*/			
					
				}
				f.println("};");
				f.println("}");
			}
			f.println("}");

			f.println("}");
			f.close();
		}
	}
	private void processInstantiation(Declaration decl) throws IOException {
		Instantiate instantiation = decl.getAnnotation(Instantiate.class);
		Template template = instantiation.type().getAnnotation(Template.class);
		if (template == null) {
			printError(decl, "Type " + instantiation.type().getName() + " is not a template. You must annotate it with " + Template.class.getName());
			return;
		}
	}

	private boolean implementsInterface(ClassDeclaration decl, String interfaceQualifiedName) {
		for (InterfaceType interf : decl.getSuperinterfaces()) {
			if (interf.getDeclaration().getQualifiedName().equals(interfaceQualifiedName))
				return true;
		}
		return false;
	}
}


#summary Jeneral Introduction & Basic example

= Introduction =

Jeneral enables the creation of pure-Java templates, using annotations.

It may be used to create :
 * *reified generics* (that is, generics that "remember" the class they were created with during runtime)
 * generics that operate seamlessly on *primitive and non-primitive types* (including when it comes to creating arrays)
 * java templates with *both class and constant parameters*
 * *inline velocity* scripts to generate even more bizarre classes

All this is done through the same syntax, with the same template class. A template class is a real pure-Java class, hence easily refactorable and with full support from IDEs such as Eclipse and Netbeans.

It also features some nifty syntactic sugar, such as a `@Property` annotation (generates getters and / or setters) or `@ImplementMissingMembers` (to avoid having to write all those dummy methods some interfaces feature when you only need to implement a single one).

= Example = 

== Setup ==

In this very simple example usage of Jeneral, you can see that there is a class `TArray_Template` that is not explicitely defined.

It is autogenerated by Apt (a standard tool bundled with the JDK). 

This autogeneration is done one-the-fly in IDEs such as Eclipse and Netbeans (just declare jeneral.jar as a Processor Factory Jar), or can be triggered manually with the following command line :

{{{ 
	apt -factoryPath jeneral.jar -cp jeneral.jar TArray.java 
}}}

For more info on how to setup your building process to use Apt, please see the TODO Installation Page.

== Template source code : TArray.java ==

{{{
import com.ochafik.lang.jeneral.*;
import com.ochafik.lang.jeneral.annotations.*;

@Template(reifiable = true)
public abstract class TArray<T> implements TArray_Template<T> { // TArray_Template is autogenerated by the compiler
	final array<T> array;
	public TArray(int initialSize) {
		array = new_T_array(initialSize);
	}
	public T get(int pos) { 
		return array.get(pos); 
	}
	public void set(int pos, T value) { 
		array.get(pos, value); 
	}
	public int size() { 
		return array.length(); 
	}

	@Property
	String simpleProperty;
	
	// This annotation triggers the generation of TArray<int>, which will be known as TArray__int :  
	@Include(
		template = TArray.class, params = { @ClassParam(Integer.TYPE.class) }
	)
	public static void main(String[] args) {
		int size = 20;
		
		// Create a reified array of int[] :
		TArray<Integer> reified = TArray_Template.Factory.newInstance(Integer.TYPE.class, size);
		reified.setSimpleProperty("OK");
		
		// Create an instantiated array of int[] (much faster than the reified one, but with no class dependance to TArray) :
		TArray__int instantiated = new TArray__int(size);
		instantiated.setSimpleProperty("OK");
	}
}
}}}

== Generated instance code : TArray_int.java ==

Note that special replacements are done for the Jeneral class `com.ochafik.lang.jeneral.array<T>` :
  * `array<T>` becomes `T[]`
  * Given a variable `myArray` of type `array<T>` :
    * `myArray.get(i)` becomes `myArray[i]`
    * `myArray.set(i, value)` becomes `myArray[i] = value`
	* `myArray.length()` becomes `myArray.length`
	
TODO `array<T>.set(int, T)` returns `T`

{{{
public class TArray_int {
	final int[] array;
	public TArray(int initialSize) {
		array = int[initialSize];
	}
	public T get(int pos) { 
		return array[pos]; 
	}
	public void set(int pos, T value) { 
		array[pos] = value; 
	}
	public int size() { 
		return array.length; 
	}

	String simpleProperty;
	
	public void setProperty(String simpleProperty) {
		this.simpleProperty = simpleProperty;
	}
	public String getProperty() {
		return simpleProperty;
	}
	
	public static void main(String[] args) {
		// ...
	}
}
}}}
